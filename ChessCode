var currentScene = 0;  //0 = splash sceen; 1= game screen; 3 = end screen
var score = 0;

var bitmojiX = 100;
var bitmojiY = 100;

//Function to create bitmoji on the screen
var drawSeanBitmoji = function (bitmojiObject){
    
    //Set bitmoji height to a fraction of the objects h value(Had to be modified for
    //correct sizing)
    var bitmojiHeight = (bitmojiObject.h)*(5/9);
    
    //Set bodyX and bodyY to object x with adjustment for displacement based on size
    var bodyX = bitmojiObject.x-bitmojiHeight;
    var bodyY = bitmojiObject.y-bitmojiHeight;
    
    //Set shirtColor to the object's shirtColor
    var shirtColor = bitmojiObject.shirtColor;
    
    //Set initialValue to the object's initials value(The variable could not be "initials" 
    //because the function to draw the initials shares that name
    var initialValue = bitmojiObject.initials;
    
    // Neck
    function neck(bodyX, bodyY, bitmojiHeight) {
        fill(255, 224, 189);
        rect(74 * (bitmojiHeight / 100) + bodyX, 139 * (bitmojiHeight / 100) + bodyY, 50 * (bitmojiHeight / 100), 30 * (bitmojiHeight / 100));
    }

    // Head
    function head(bodyX, bodyY, bitmojiHeight) {
        fill(255, 224, 189);
        ellipse(100 * (bitmojiHeight / 100) + bodyX, 100 * (bitmojiHeight / 100) + bodyY, 80 * (bitmojiHeight / 100), 100 * (bitmojiHeight / 100));
    }

    // Hair
    function hair(bodyX, bodyY, bitmojiHeight) {
        noStroke();
        fill(245, 212, 103);
        ellipse(100 * (bitmojiHeight / 100) + bodyX, 61 * (bitmojiHeight / 100) + bodyY, 70 * (bitmojiHeight / 100), 34 * (bitmojiHeight / 100));
        quad(
            64 * (bitmojiHeight / 100) + bodyX,
            56 * (bitmojiHeight / 100) + bodyY,
            80 * (bitmojiHeight / 100) + bodyX,
            46 * (bitmojiHeight / 100) + bodyY,
            92 * (bitmojiHeight / 100) + bodyX,
            77 * (bitmojiHeight / 100) + bodyY,
            59 * (bitmojiHeight / 100) + bodyX,
            92 * (bitmojiHeight / 100) + bodyY
        );
        quad(
            134 * (bitmojiHeight / 100) + bodyX,
            56 * (bitmojiHeight / 100) + bodyY,
            89 * (bitmojiHeight / 100) + bodyX,
            63 * (bitmojiHeight / 100) + bodyY,
            106 * (bitmojiHeight / 100) + bodyX,
            85 * (bitmojiHeight / 100) + bodyY,
            143 * (bitmojiHeight / 100) + bodyX,
            90 * (bitmojiHeight / 100) + bodyY
        );
    }

    // Eyes
    function eyes(bodyX, bodyY, bitmojiHeight) {
        stroke(0, 0, 0);
        fill(255, 255, 255);
        ellipse(82 * (bitmojiHeight / 100) + bodyX, 100 * (bitmojiHeight / 100) + bodyY, 18 * (bitmojiHeight / 100), 13 * (bitmojiHeight / 100));
        ellipse(118 * (bitmojiHeight / 100) + bodyX, 100 * (bitmojiHeight / 100) + bodyY, 18 * (bitmojiHeight / 100), 13 * (bitmojiHeight / 100));
        noStroke();
        fill(64, 139, 166);
        ellipse(82 * (bitmojiHeight / 100) + bodyX, 100 * (bitmojiHeight / 100) + bodyY, 9 * (bitmojiHeight / 100), 9 * (bitmojiHeight / 100));
        ellipse(118 * (bitmojiHeight / 100) + bodyX, 100 * (bitmojiHeight / 100) + bodyY, 9 * (bitmojiHeight / 100), 9 * (bitmojiHeight / 100));
        fill(0, 0, 0);
        ellipse(82 * (bitmojiHeight / 100) + bodyX, 100 * (bitmojiHeight / 100) + bodyY, 4 * (bitmojiHeight / 100), 4 * (bitmojiHeight / 100));
        ellipse(118 * (bitmojiHeight / 100) + bodyX, 100 * (bitmojiHeight / 100) + bodyY, 4 * (bitmojiHeight / 100), 4 * (bitmojiHeight / 100));
    }

    // Nose
    function nose(bodyX, bodyY, bitmojiHeight) {
        stroke(0, 0, 0);
        fill(255, 224, 189);
        bezier(
            98 * (bitmojiHeight / 100) + bodyX,
            119 * (bitmojiHeight / 100) + bodyY,
            110 * (bitmojiHeight / 100) + bodyX,
            123 * (bitmojiHeight / 100) + bodyY,
            109 * (bitmojiHeight / 100) + bodyX,
            103 * (bitmojiHeight / 100) + bodyY,
            98 * (bitmojiHeight / 100) + bodyX,
            97 * (bitmojiHeight / 100) + bodyY
        );
    }

    // Mouth
    function mouth(bodyX, bodyY, bitmojiHeight) {
        fill(237, 168, 168);
        ellipse(101 * (bitmojiHeight / 100) + bodyX, 131 * (bitmojiHeight / 100) + bodyY, 21 * (bitmojiHeight / 100), 8 * (bitmojiHeight / 100));
        line(
            91 * (bitmojiHeight / 100) + bodyX,
            131 * (bitmojiHeight / 100) + bodyY,
            109 * (bitmojiHeight / 100) + bodyX,
            131 * (bitmojiHeight / 100) + bodyY
        );
    }

    // EyeBlack
    function eyeBlack(bodyX, bodyY, bitmojiHeight) {
        fill(36, 36, 36);
        rect(
            73 * (bitmojiHeight / 100) + bodyX,
            108 * (bitmojiHeight / 100) + bodyY,
            18 * (bitmojiHeight / 100),
            5 * (bitmojiHeight / 100),
            30
        );
        rect(
            110 * (bitmojiHeight / 100) + bodyX,
            108 * (bitmojiHeight / 100) + bodyY,
            18 * (bitmojiHeight / 100),
            5 * (bitmojiHeight / 100),
            30
        );
    }

    // Shirt
    function shirt(bodyX, bodyY, bitmojiHeight) {
        //Use the object's shirtColor
        fill(shirtColor);
        arc(
            100 * (bitmojiHeight / 100) + bodyX,
            193 * (bitmojiHeight / 100) + bodyY,
            116 * (bitmojiHeight / 100),
            69 * (bitmojiHeight / 100),
            -180,
            0
        );
        noStroke();
        rect(41 * (bitmojiHeight / 100) + bodyX, 192 * (bitmojiHeight / 100) + bodyY, 118 * (bitmojiHeight / 100), 37 * (bitmojiHeight / 100));
        fill(255, 224, 189);
        triangle(
            74 * (bitmojiHeight / 100) + bodyX,
            156 * (bitmojiHeight / 100) + bodyY,
            124 * (bitmojiHeight / 100) + bodyX,
            156 * (bitmojiHeight / 100) + bodyY,
            101 * (bitmojiHeight / 100) + bodyX,
            178 * (bitmojiHeight / 100) + bodyY
        );
        stroke(0, 0, 0);
        line(41 * (bitmojiHeight / 100) + bodyX, 192 * (bitmojiHeight / 100) + bodyY, 41 * (bitmojiHeight / 100) + bodyX, 227 * (bitmojiHeight / 100) + bodyY);
        line(
            158 * (bitmojiHeight / 100) + bodyX,
            192 * (bitmojiHeight / 100) + bodyY,
            158 * (bitmojiHeight / 100) + bodyX,
            227 * (bitmojiHeight / 100) + bodyY
        );
    }

    // ShirtCollar
    function shirtCollar(bodyX, bodyY, bitmojiHeight) {
        //Use the object's shirt color again
        fill(shirtColor);
        quad(
            65 * (bitmojiHeight / 100) + bodyX,
            160 * (bitmojiHeight / 100) + bodyY,
            77 * (bitmojiHeight / 100) + bodyX,
            159 * (bitmojiHeight / 100) + bodyY,
            105 * (bitmojiHeight / 100) + bodyX,
            186 * (bitmojiHeight / 100) + bodyY,
            71 * (bitmojiHeight / 100) + bodyX,
            177 * (bitmojiHeight / 100) + bodyY
        );
        quad(
            133 * (bitmojiHeight / 100) + bodyX,
            160 * (bitmojiHeight / 100) + bodyY,
            121 * (bitmojiHeight / 100) + bodyX,
            159 * (bitmojiHeight / 100) + bodyY,
            98 * (bitmojiHeight / 100) + bodyX,
            185 * (bitmojiHeight / 100) + bodyY,
            129 * (bitmojiHeight / 100) + bodyX,
            175 * (bitmojiHeight / 100) + bodyY
        );
        rect(95 * (bitmojiHeight / 100) + bodyX, 184 * (bitmojiHeight / 100) + bodyY, 10 * (bitmojiHeight / 100), 18 * (bitmojiHeight / 100));
        triangle(
            112 * (bitmojiHeight / 100) + bodyX,
            171 * (bitmojiHeight / 100) + bodyY,
            101 * (bitmojiHeight / 100) + bodyX,
            183 * (bitmojiHeight / 100) + bodyY,
            117 * (bitmojiHeight / 100) + bodyX,
            183 * (bitmojiHeight / 100) + bodyY
        );
        triangle(
            88 * (bitmojiHeight / 100) + bodyX,
            171 * (bitmojiHeight / 100) + bodyY,
            84 * (bitmojiHeight / 100) + bodyX,
            183 * (bitmojiHeight / 100) + bodyY,
            102 * (bitmojiHeight / 100) + bodyX,
            183 * (bitmojiHeight / 100) + bodyY
        );
        fill(176, 212, 207);
        ellipse(100.5 * (bitmojiHeight / 100) + bodyX, 191 * (bitmojiHeight / 100) + bodyY, 4 * (bitmojiHeight / 100), 4 * (bitmojiHeight / 100));
        ellipse(100.5 * (bitmojiHeight / 100) + bodyX, 197 * (bitmojiHeight / 100) + bodyY, 4 * (bitmojiHeight / 100), 4 * (bitmojiHeight / 100));
    }

    // Initials
    function initials(bodyX, bodyY, bitmojiHeight) {
        fill(255, 255, 255);
        textSize(20 * (bitmojiHeight / 100));
        text("SH", 55 * (bitmojiHeight / 100) + bodyX, 188 * (bitmojiHeight / 100) + bodyY, 300, 300);
    }

    // Emblem
    function emblem(bodyX, bodyY, bitmojiHeight) {
        line(
            125 * (bitmojiHeight / 100) + bodyX,
            188 * (bitmojiHeight / 100) + bodyY,
            132 * (bitmojiHeight / 100) + bodyX,
            207 * (bitmojiHeight / 100) + bodyY
        );
        fill(224, 38, 38);
        triangle(
            125 * (bitmojiHeight / 100) + bodyX,
            188 * (bitmojiHeight / 100) + bodyY,
            130 * (bitmojiHeight / 100) + bodyX,
            200 * (bitmojiHeight / 100) + bodyY,
            145 * (bitmojiHeight / 100) + bodyX,
            190 * (bitmojiHeight / 100) + bodyY
        );
        noFill();
        stroke(255, 255, 255);
        ellipse(
            131 * (bitmojiHeight / 100) + bodyX,
            193 * (bitmojiHeight / 100) + bodyY,
            3 * (bitmojiHeight / 100),
            3 * (bitmojiHeight / 100)
        );
        line(
            133 * (bitmojiHeight / 100) + bodyX,
            193 * (bitmojiHeight / 100) + bodyY,
            139 * (bitmojiHeight / 100) + bodyX,
            190.5 * (bitmojiHeight / 100) + bodyY
        );
        fill(0, 0, 0);
        textSize(5 * (bitmojiHeight / 100));
        text("Keyport", 139 * (bitmojiHeight / 100) + bodyX, 199 * (bitmojiHeight / 100) + bodyY);
        text("Yacht", 132 * (bitmojiHeight / 100) + bodyX, 204 * (bitmojiHeight / 100) + bodyY);
        text("Club", 147 * (bitmojiHeight / 100) + bodyX, 204 * (bitmojiHeight / 100) + bodyY);
        textSize(6.5 * (bitmojiHeight / 100));
        text("Junior", 115 * (bitmojiHeight / 100) + bodyX, 212 * (bitmojiHeight / 100) + bodyY);
        text("Sailing", 135 * (bitmojiHeight / 100) + bodyX, 212 * (bitmojiHeight / 100) + bodyY);
        text("Instructor", 121 * (bitmojiHeight / 100) + bodyX, 219 * (bitmojiHeight / 100) + bodyY);
    }

    // Sunglasses
    function sunglasses(bodyX, bodyY, bitmojiHeight) {
        stroke(0, 0, 0);
        fill(37, 51, 16, 127);
        ellipse(104 * (bitmojiHeight / 100) + bodyX, 189 * (bitmojiHeight / 100) + bodyY, 15 * (bitmojiHeight / 100), 17 * (bitmojiHeight / 100));
        ellipse(104 * (bitmojiHeight / 100) + bodyX, 210 * (bitmojiHeight / 100) + bodyY, 15 * (bitmojiHeight / 100), 17 * (bitmojiHeight / 100));
        fill(0, 0, 0);
        line(
            111 * (bitmojiHeight / 100) + bodyX,
            211 * (bitmojiHeight / 100) + bodyY,
            111 * (bitmojiHeight / 100) + bodyX,
            188 * (bitmojiHeight / 100) + bodyY
        );
        line(
            108 * (bitmojiHeight / 100) + bodyX,
            202 * (bitmojiHeight / 100) + bodyY,
            108 * (bitmojiHeight / 100) + bodyX,
            195 * (bitmojiHeight / 100) + bodyY
        );
    }

    neck(bodyX, bodyY, bitmojiHeight);
    head(bodyX, bodyY, bitmojiHeight);
    hair(bodyX, bodyY, bitmojiHeight);
    eyes(bodyX, bodyY, bitmojiHeight);
    nose(bodyX, bodyY, bitmojiHeight);
    mouth(bodyX, bodyY, bitmojiHeight);
    eyeBlack(bodyX, bodyY, bitmojiHeight);
    shirt(bodyX, bodyY, bitmojiHeight);
    shirtCollar(bodyX, bodyY, bitmojiHeight);
    
    //Check if initials are true or false before drawing them
    if(initialValue === true){
        initials(bodyX, bodyY, bitmojiHeight);
    }
    emblem(bodyX, bodyY, bitmojiHeight);
    sunglasses(bodyX, bodyY, bitmojiHeight);
};

//Call drawBitmoji Function

var drawHead = function (x, y, bitmojiHeight)

{
  var ratio = bitmojiHeight/100; 
    noStroke();
    fill(255, 224, 184); //skin color
    ellipse(x,y,83*ratio,100*ratio); //head
    fill(169, 125, 50); //hair color
    quad(x-43*ratio,y-7*ratio,x-29*ratio,y-36*ratio,x-12*ratio,y-48*ratio,x-34*ratio,y     +3*ratio); //left hair
    quad(x+43*ratio,y+1*ratio,x+34*ratio,y-32*ratio,x+13*ratio,y-50*ratio,x+35*ratio,y     -3*ratio); //right hair
    fill(0, 0, 0); //hat color
    ellipse(x+1*ratio,y-38*ratio,58*ratio,27*ratio); //hat
    fill(99,57,15); //eye color
    stroke(0, 0, 0);
    ellipse(x-12*ratio,y,6*ratio,4*ratio); //left eye
    ellipse(x+16*ratio,y,6*ratio,4*ratio); //right eye
    fill(255, 224, 184); //nose color
    bezier(x,y,x+21*ratio,y+22*ratio,x-8*ratio,y+20*ratio,x-4*ratio,y+15*ratio); //nose
    fill(255, 255, 255); //white for smile
    arc(x,y+25*ratio,29*ratio,13*ratio,1,180); //smile
    line(x-16*ratio,y+24*ratio,x+14*ratio,y+24*ratio); //line for smile
};

var drawShirt = function(x, y, bitmojiHeight){
var ratio = bitmojiHeight/100;   
    
    fill(0, 0, 0); //shirt color
    rect(x-35*ratio,y+50*ratio,71*ratio,63*ratio); //shirt
    rect(x-45*ratio,y+50*ratio,11*ratio,37*ratio); //left sholder sleeve
    rect(x+35*ratio,y+50*ratio,11*ratio,37*ratio); //right sholder sleeve
    fill(247, 247, 247); //text color
    textSize(20*ratio);
    text("CH",x-13*ratio,y+78*ratio);
};

var drawCamBitmoji = function(x, y, h){

    drawHead (x, y, h);
    drawShirt (x, y, h);
    };

var Button = function(config) {
    this.x = config.x || 0;
    this.y = config.y || 0;
    this.width = config.width || 150;
    this.height = config.height || 50;
    this.label = config.label || "Click";
    this.onClick = config.onClick || function() {};
};

Button.prototype.draw = function() {
    fill(234, 221, 202);
    rect(this.x, this.y, this.width, this.height, 5);
    fill(0, 0, 0);
    textSize(19);
    //textAlign(LEFT, TOP);
    text(this.label, this.x+44, this.y+this.height-20);
};

Button.prototype.isMouseInside = function() {
    return mouseX > this.x &&
           mouseX < (this.x + this.width) &&
           mouseY > this.y &&
           mouseY < (this.y + this.height);
};

Button.prototype.handleMouseClick = function() {
    if (this.isMouseInside()) {
        this.onClick();
    }
};


var startButton = new Button({
    x: 121,
    y: 300,
    label: "START",
    onClick: function() {
        currentScene = 1;
        
    }
});

var splashScreen = function ()
{
    background(110, 28, 13);
    drawCamBitmoji(347,39,55);
    drawSeanBitmoji({
    x:48,
    y:39,
    h:89,
    shirtColor:color(255, 255, 255),
    initials:false});
    fill(234, 221, 202);
    textSize(25);
    text ("By Cameron and Sean ", 71,184);
    textSize(40);
    text("Chess", 143,122);
    textSize(20);
    text("Click the start button to start the game",28,238);
    startButton.draw();
    startButton.draw();
};

var gameScreen = function ()
{
    
    
};

var endScreen = function ()
{
    background(255, 0, 0);
    
};

var turn = "white";

var simulation = false;

var gameEnd = false;

var checkingCheckmate = false;

var Tile = function(tileX, tileY, tileRight, tileUp){
    
    this.tileX = tileX;
    this.tileY = tileY;
    this.tileLeftBound = tileX;
    this.tileRightBound = tileX+47.625;
    this.tileTopBound = tileY;
    this.tileBottomBound = tileY+ 47.625;
    this.tileRight = tileRight;
    this.tileUp = tileUp;
    this.piece = null;
    
};

var Piece = function(type, tileRight, tileUp, team){
    
    this.type = type;
    this.team = team;
    this.tileRight = tileRight;
    this.tileUp = tileUp;
    this.selected = false;
    
};

var rows = [];

Piece.prototype.draw = function(){
    
    if (this.team === "white"){
        
        stroke(255, 255, 255);
        strokeWeight(1);
        fill(255, 255, 255);
    }
    else {
        stroke(0, 0, 0);
        strokeWeight(1);
        fill(0, 0, 0);
    }
    
    textSize(12);
    
    var tileRight = this.tileRight;
    var tileUp = this.tileUp;
    
    // Check if tile indices are valid
    
    
    if (tileRight !== null && tileUp !== null && rows[tileRight] && (rows[tileRight])[tileUp]) {
        
        var tile = this.getTile();
        
        if (this.selected) {
        fill(255, 0, 0, 35); // Red with 100 alpha (semi-transparent)
        rect(tile.tileX, tile.tileY, 47.625, 47.625);
    }
        
        ellipse(tile.tileX+24, tile.tileY+24, 40, 40);
        
        if (this.team === "white"){
            stroke(0, 0, 0);
            strokeWeight(1);
            fill(0, 0, 0);
            
        }
        else {
            stroke(255, 255, 255);
            strokeWeight(1);
            fill(255, 255, 255);
        }
        
        var textAdjust;
        if (this.type === "rook" || this.type === "king"){
            
            textAdjust = 12;
            
        }
        else if(this.type === "queen"){
            
            textAdjust = 7;
            
        }
        else if(this.type === "bishop"){
            
            textAdjust = 6;
            
        }
        else if(this.type === "knight"){
            
            textAdjust = 8;
            
        }
        else if(this.type === "pawn"){
            
            textAdjust = 9;
            
        }
        
        text(this.type, tile.tileX+textAdjust, tile.tileY+27);
        
    }
    
    //rect(this.pawnX, this.pawnY, 47.625, 47.625);
    
};

Piece.prototype.getTile = function(){
    
    var tile = (rows[this.tileRight])[this.tileUp];
    return tile;
    
};

var findKing = function(){
    
    var kingPiece = null;
    
    for (var i = 0; i < rows.length; i++) {
        for (var j = 0; j < rows[i].length; j++) {
            
            var checkTile = rows[i][j];
            
            if (checkTile.piece !== null) {
                
                var checkPiece = checkTile.piece;
                
                if (checkPiece.team === turn && checkPiece.type === "king"){
                    
                    return checkTile;
                    
                }
            }
        }
    }
};

var pawnCheck = function(currentPiece, targetTile){
    
    var type = currentPiece.type;
    var team = currentPiece.team;
    var backwards = 1;
    var turn = currentPiece.team;
    
    if (team === "black"){
        backwards = -1;
        }
        
        var tile = currentPiece.getTile();
        
        if(targetTile.tileUp === tile.tileUp+(1*backwards)){
            
            if (targetTile.piece === null && targetTile.tileRight=== tile.tileRight){
                return true;
            }
            else if (targetTile.piece !== null){
                if ((targetTile.piece.team !== turn) && (targetTile.tileRight === tile.tileRight + 1 || targetTile.tileRight === tile.tileRight - 1)){
                    return true;
                }
            }
            
        }
        
        else if((targetTile.tileUp === tile.tileUp+(2*backwards))&&currentPiece.firstTurn === true && targetTile.tileRight === tile.tileRight){
            
            return true;
        }
    
};

var bishopCheck = function(currentPiece, targetTile){
    
    var type = currentPiece.type;
    var team = currentPiece.team;
    var turn = currentPiece.team;
    
    var currentTile = currentPiece.getTile();
        
        var dx = (targetTile.tileRight - currentTile.tileRight);
        var dy = (targetTile.tileUp - currentTile.tileUp);
        
        if (abs(dx) === abs(dy)){
            
            if (dx > 0 && dy > 0){
                //Up and Right
                for (var i = 1; i < 8; i++){
                    
                    var checkTile = (((rows[currentTile.tileRight+i])[currentTile.tileUp+i]));
                    
                    if (checkTile.piece !== null){
                        
                        if ((checkTile.piece).team !== turn){
                                
                            if (checkTile === targetTile){
                                
                                return true;
                                
                            }
                            else{
                                break;
                            }
                            
                        }
                        else{
                            break;
                        }
                    
                    }
                    else{
                        
                        if (checkTile === targetTile){
                            
                            return true;
                            
                        }
                        
                    }
                }
            }
            
            else if (dx > 0 && dy < 0){
                //Down and Right
                
                for (var i = 1; i < 8; i++){
                    
                    var checkTile = (((rows[currentTile.tileRight+i])[currentTile.tileUp-i]));
                    
                    if (checkTile.piece !== null){
                        
                        if ((checkTile.piece).team !== turn){
                                
                            if (checkTile === targetTile){
                                
                                return true;
                                
                            }
                            else{
                                break;
                            }
                            
                        }
                        else{
                            break;
                        }
                    
                    }
                    else{
                        
                        if (checkTile === targetTile){
                            
                            return true;
                            
                        }
                        
                    }
                }
                
            }
            else if (dx < 0 && dy > 0){
                //Up and Left
                
                for (var i = 1; i < 8; i++){
                    
                    var checkTile = (((rows[currentTile.tileRight-i])[currentTile.tileUp+i]));
                    
                    if (checkTile.piece !== null){
                        
                        if ((checkTile.piece).team !== turn){
                                
                            if (checkTile === targetTile){
                                
                                return true;
                                
                            }
                            else{
                                break;
                            }
                            
                        }
                        else{
                            break;
                        }
                    
                    }
                    else{
                        
                        if (checkTile === targetTile){
                            
                            return true;
                            
                        }
                        
                    }
                }
            }
            else if (dx < 0 && dy < 0){
                //Down and Left
                
                for (var i = 1; i < 8; i++){
                    
                    var checkTile = (((rows[currentTile.tileRight-i])[currentTile.tileUp-i]));
                    
                    if (checkTile.piece !== null){
                        
                        if ((checkTile.piece).team !== turn){
                                
                            if (checkTile === targetTile){
                                
                                return true;
                                
                            }
                            else{
                                break;
                            }
                            
                        }
                        else{
                            break;
                        }
                    
                    }
                    else{
                        
                        if (checkTile === targetTile){
                            
                            return true;
                            
                        }
                        
                    }
                }
            }
            
            
        }
    
};

var rookCheck = function(currentPiece, targetTile){
    
    var type = currentPiece.type;
    var team = currentPiece.team;
    var turn = currentPiece.team;
    
    var currentTile = currentPiece.getTile();
        
        var dx = (targetTile.tileRight - currentTile.tileRight);
        var dy = (targetTile.tileUp - currentTile.tileUp);
            
            
            if (dx === 0 || dy === 0){
                
                if (dy !== 0){
                for (var i = 1; i < 8; i++){
                    
                    var multiplier = 1;
                    if (dy < 0){
                        multiplier = -1;
                    }
                    var checkTile = (((rows[currentTile.tileRight])[currentTile.tileUp+(i*multiplier)]));
                    
                    if (checkTile.piece !== null){
                        
                        if ((checkTile.piece).team !== turn){
                                
                            if (checkTile === targetTile){
                                
                                return true;
                                
                            }
                            else{
                                break;
                            }
                            
                        }
                        else{
                            break;
                        }
                    
                    }
                    else{
                        
                        if (checkTile === targetTile){
                            
                            return true;
                            
                        }
                        
                    }
                }
                
                }
                
                if (dx !== 0){
                for (var i = 1; i < 8; i++){
                    
                    var multiplier = 1;
                    if (dx < 0){
                        multiplier = -1;
                    }
                    var checkTile = (((rows[currentTile.tileRight+(i*multiplier)])[currentTile.tileUp]));
                    
                    if (checkTile.piece !== null){
                        
                        if ((checkTile.piece).team !== turn){
                                
                            if (checkTile === targetTile){
                                
                                return true;
                                
                            }
                            else{
                                break;
                            }
                            
                        }
                        else{
                            break;
                        }
                    
                    }
                    else{
                        
                        if (checkTile === targetTile){
                            
                            return true;
                            
                        }
                        
                    }
                }
                }
            }
    
};

var knightCheck = function(currentPiece, targetTile){
    
    var type = currentPiece.type;
    var team = currentPiece.team;
    var turn = currentPiece.team;
    
    var currentTile = currentPiece.getTile();
        
        var dx = abs(targetTile.tileRight - currentTile.tileRight);
        var dy = abs(targetTile.tileUp - currentTile.tileUp);
        
        if ((dx === 2 && dy === 1) || (dx === 1 && dy === 2)){
            
            if (targetTile.piece !== null){
                
                if ((targetTile.piece).team !== turn){
                    return true;
                }
                
            }
            else {
                return true;
            }
            
        }
    
};

var kingCheck = function(currentPiece, targetTile){
    
    var type = currentPiece.type;
    var team = currentPiece.team;
    var turn = currentPiece.team;
    
    var currentTile = currentPiece.getTile();
        
    var dx = abs(targetTile.tileRight - currentTile.tileRight);
    var dy = abs(targetTile.tileUp - currentTile.tileUp);
    
    if ((dx <= 1 && dy <= 1) && !(dx === 0 && dy === 0)){
        if (targetTile.piece !== null){
            if ((targetTile.piece).team !== turn){
                
                return true;
                
            }
        }
        else{
            return true;
        }
    }
    
};

var checkValidMove = function(currentPiece, targetTile){
    
    var type = currentPiece.type;
    
    if (type === "pawn"){
        
        if (pawnCheck(currentPiece, targetTile) && currentPiece.simulateMove(currentPiece, targetTile)){
            
            currentPiece.move(targetTile.tileRight, targetTile.tileUp);
            
        }
        
    }
    
    else if(type === "bishop"){
        
        if (bishopCheck(currentPiece, targetTile)&& currentPiece.simulateMove(currentPiece, targetTile)){
            currentPiece.move(targetTile.tileRight, targetTile.tileUp);
        }
        
    }
    
    else if(type === "rook"){
        
        if (rookCheck(currentPiece, targetTile)&& currentPiece.simulateMove(currentPiece, targetTile)){
            currentPiece.move(targetTile.tileRight, targetTile.tileUp);
        }
        
    }
    
    else if (type === "queen"){
        
        if ((rookCheck(currentPiece, targetTile) || bishopCheck(currentPiece, targetTile))&& currentPiece.simulateMove(currentPiece, targetTile)){
            currentPiece.move(targetTile.tileRight, targetTile.tileUp);
        }
        
    }
    
    else if(type === "knight"){
        
        if (knightCheck(currentPiece, targetTile)&& currentPiece.simulateMove(currentPiece, targetTile)){
            
            currentPiece.move(targetTile.tileRight, targetTile.tileUp);
            
        }
        
    }
    
    else if(type === "king"){
        
        //Don't forget to add in a check for check
        if (kingCheck(currentPiece, targetTile)&& currentPiece.simulateMove(currentPiece, targetTile)&& currentPiece.simulateMove(currentPiece, targetTile)){
            
            currentPiece.move(targetTile.tileRight, targetTile.tileUp);
            
        }
        
    }
    
};

var isInCheck = function(){
    
    var kingTile = findKing();
    var inCheck = false;
    
    for (var i = 0; i < rows.length; i++) {
        for (var j = 0; j < rows[i].length; j++) {
            
            var checkTile = (rows[i])[j];
            
            if (checkTile.piece !== null) {
                
                var checkPiece = checkTile.piece;
                
                if (checkPiece.team !== turn){
                    
                    if (checkPiece.type === "pawn"){
                        
                        if (pawnCheck(checkPiece, kingTile)){
                            
                            
                            inCheck = true;
                        }
                    }
                    else if (checkPiece.type === "rook"){
                        
                        if (rookCheck(checkPiece, kingTile)){
                            
                            inCheck = true;
                        }
                    }
                    else if (checkPiece.type === "knight"){
                        
                        if (knightCheck(checkPiece, kingTile)){
                            
                            inCheck = true;
                        }
                    }
                    else if (checkPiece.type === "bishop"){
                        
                        if (bishopCheck(checkPiece, kingTile)){
                            
                            inCheck = true;
                        }
                    }
                    else if (checkPiece.type === "queen"){
                        
                        if (rookCheck(checkPiece, kingTile) || bishopCheck(checkPiece, kingTile)){
                            
                            inCheck = true;
                        }
                    }
                    else if (checkPiece.type === "king"){
                        if (kingCheck(checkPiece, kingTile)){
                            
                            inCheck = true;
                        }
                    }
                }
            }
        }
    }
    
    return inCheck;
    
};

var isCheckmate = function(){
    
    checkingCheckmate = true;
    var currentTurn = turn;
    var movesPossible = false;
    
    textAlign(BASELINE);
    
    for (var i = 0; i < rows.length; i++) {
        
        for (var j = 0; j < rows[i].length; j++) {
            
            var piece = null;
            
            if ((rows[i])[j].piece !== null){
                piece = (rows[i])[j].piece;
            }
            
            // Consider only pieces of the current player's team
            if (piece !== null && piece.team === currentTurn) {
                
                // Check all possible moves for the current piece
                for (var x = 0; x < rows.length; x++) {
                    for (var y = 0; y < rows[x].length; y++) {
                        
                        var targetTile = (rows[x])[y];
                        
                        // If the move is valid and doesn't result in check, it's not checkmate               
                        if (piece.type === "pawn"){
                            if (pawnCheck(piece, targetTile) && piece.simulateMove(piece, targetTile)) {
                             movesPossible = true;// Not checkmate
                            
                        }
                        }
                        else if(piece.type === "rook"){
                            if (rookCheck(piece, targetTile) && piece.simulateMove(piece, targetTile)) {
                             movesPossible = true;// Not checkmate
                            
                        }
                        }
                        else if(piece.type === "knight"){
                            if (knightCheck(piece, targetTile) && piece.simulateMove(piece, targetTile)) {
                             movesPossible = true;// Not checkmate
                            
                        }
                        }
                        else if(piece.type === "bishop"){
                            if (bishopCheck(piece, targetTile) && piece.simulateMove(piece, targetTile)) {
                             movesPossible = true;// Not checkmate
                            
                        }
                        }
                        else if(piece.type === "queen"){
                            if ((bishopCheck(piece, targetTile)||rookCheck(piece, targetTile)) && piece.simulateMove(piece, targetTile)) {
                             movesPossible = true;// Not checkmate
                            
                        }
                        }
                        else if(piece.type === "king"){
                            
                            if (kingCheck(piece, targetTile) && piece.simulateMove(piece, targetTile)) {
                            
                             movesPossible = true;// Not checkmate
                            
                        }
                        }
                        
                    }
                }
            }
        }
    }
    // If no valid move can get the king out of check, it's checkmate
    
    
    return !movesPossible;
    
};

Piece.prototype.move = function(newInd, newInd2){
    
    var newTile = ((rows[newInd])[newInd2]);
    
    var oldTile = this.getTile();
    
    var tempPiece = oldTile.piece;
    
    tempPiece.selected = false;
    
    tempPiece.tileRight = newInd;
    
    tempPiece.tileUp = newInd2;
    
    oldTile.piece = null;
    
    newTile.piece = tempPiece;
    
    newTile.tileRight = newInd;
    newTile.tileUp = newInd2;
    
    if (turn === "white"){
        turn = "black";
    }
    else{
        turn = "white";
    }
    
    if (this.firstTurn === true){
        this.firstTurn = false;
    }
    
    if (simulation === false){
        checkingCheckmate = false;
    }
    
    //isInCheck();
   
};

Piece.prototype.simulateMove = function(piece, targetTile) {
    // Store the original state
    simulation = true;
    var originalTurn = turn;
    var originalTile = piece.getTile();
    var originalPieceAtTarget = null;
    
    if (targetTile.piece !== null){
        originalPieceAtTarget = targetTile.piece;
    }
    
    // Apply the move
    piece.move(targetTile.tileRight, targetTile.tileUp);

    // Check the consequences
    
    turn = originalTurn;
    var isInCheckAfterMove = isInCheck();
    
    // Revert the state
    piece.move(originalTile.tileRight, originalTile.tileUp);
    
    if (originalPieceAtTarget !== null){
        
        targetTile.piece = originalPieceAtTarget;
    
    }
    
    turn = originalTurn;
    simulation = false;
    return !isInCheckAfterMove;
    
};

var boardInit = function(){
    
    background(110, 38, 14);
    noFill();
    strokeWeight(2);
    stroke(234, 221, 202);
    rect(8, 8, 384, 384);
    
    strokeWeight(1);
    
    stroke(0, 0, 0);
    
    line(9, 9, 390, 9);
    for (var i = 0; i < 8; i++){
        
        for (var j = 0; j < 8; j++){
            
            if ((j%2)=== 0  && i%2 === 0){
                fill(234,221,202);
            }
            else if (i%2 !== 0 && j%2 !==0){
                fill(234, 221, 202);
            } 
            else {
                fill(110, 28, 13);
            }
            rect((47.625*j)+9,(47.625*i)+9, 47.625, 47.625);
            
        }
    }
    
};

var letters = ["a", "b", "c", "d", "e", "f", "g", "h"];

for (var i = 0; i < 8; i++){
    
    var row = [];
    
    for (var j = 0; j < 8; j++){
        
        row.push(new Tile((47.625*i)+9, (47.625*j)+9, i, 7-j));
        
    }
    
    row = row.reverse();
    rows.push(row);

}

//Create Pawns
for (var i = 0; i < 16; i++){
    
    if (i < 8){
        
        ((rows[i])[1]).piece = (new Piece("pawn", i, 1, "white"));
        (((rows[i])[1]).piece).firstTurn = true;
    }
    else{
        ((rows[i-8])[6]).piece = (new Piece("pawn", i-8, 6, "black"));
        (((rows[i-8])[6]).piece).firstTurn = true;
    }
    
}

//Create other pieces
//Bishops

((rows[2])[0]).piece = (new Piece("bishop", 2,0, "white"));
((rows[5])[0]).piece = (new Piece("bishop", 5,0, "white"));
((rows[2])[7]).piece = (new Piece("bishop", 2,7, "black"));
((rows[5])[7]).piece = (new Piece("bishop", 5,7, "black"));

//Rooks
((rows[0])[0]).piece = (new Piece("rook", 0,0, "white"));
((rows[7])[0]).piece = (new Piece("rook", 7,0, "white"));
((rows[0])[7]).piece = (new Piece("rook", 0,7, "black"));
((rows[7])[7]).piece = (new Piece("rook", 7,7, "black"));

//Queens
((rows[3])[0]).piece = (new Piece("queen", 3,0, "white"));
((rows[3])[7]).piece = (new Piece("queen", 3,7, "black"));

//Knights
((rows[1])[0]).piece = (new Piece("knight", 1,0, "white"));
((rows[6])[0]).piece = (new Piece("knight", 6,0, "white"));
((rows[1])[7]).piece = (new Piece("knight", 1,7, "black"));
((rows[6])[7]).piece = (new Piece("knight", 6,7, "black"));

//Kings
((rows[4])[0]).piece = (new Piece("king", 4,0, "white"));
((rows[4])[7]).piece = (new Piece("king", 4,7, "black"));

var getSelectedPiece = function() {
    for (var i = 0; i < rows.length; i++) {
        for (var j = 0; j < rows[i].length; j++) {
            var currentPiece = rows[i][j].piece;
            if (currentPiece && currentPiece.selected) {
                return currentPiece;
            }
        }
    }
    return null;
};

Piece.prototype.onClick = function(){
    
    var tile = this.getTile();
    
    if (turn === this.team){
    for (var i = 0; i < rows.length; i++) {
        for (var j = 0; j < rows[i].length; j++) {
            if (rows[i][j].piece !== null) {
                rows[i][j].piece.selected = false;
            }
        }
    }

    // Select the current piece
    
    this.selected = !this.selected;
    }
    else if(turn !== this.team){
        var selectedPiece = getSelectedPiece();
        
        if (selectedPiece) {
            checkValidMove(selectedPiece, tile);
        }
    }
};

Tile.prototype.onClick = function(){
    //Check if a piece is selected already
    for (var i = 0; i < rows.length; i++){
        for (var j = 0; j < (rows[i]).length; j++){
            var currentPiece = (((rows[i])[j]).piece);
            
            if (currentPiece !== null){
                
                if (currentPiece.selected === true){
                    checkValidMove(currentPiece, this);
                }
            }
        }
    }
    
};

Piece.prototype.isMouseInside = function() {
    
    
    var tile = this.getTile();
    
    return mouseX > tile.tileLeftBound &&
           mouseX < (tile.tileRightBound) &&
           mouseY > tile.tileTopBound &&
           mouseY < (tile.tileBottomBound);
};

Tile.prototype.isMouseInside = function() {
    return mouseX > this.tileLeftBound &&
           mouseX < (this.tileRightBound) &&
           mouseY > this.tileTopBound &&
           mouseY < (this.tileBottomBound);
    
};

Piece.prototype.handleMouseClick = function() {
    if (this.isMouseInside()) {
        
        this.onClick();
    }
};

Tile.prototype.handleMouseClick = function() {

    if (this.isMouseInside()) {
        this.onClick();
    }
    
};

mouseClicked = function() {
    
    if (currentScene === 0){
        
        startButton.handleMouseClick();
        
    }
    else if(currentScene === 1){
    for (var i = 0; i < rows.length; i++){
        for (var j = 0; j < (rows[i]).length; j++){
            var currentPiece = (((rows[i])[j]).piece);
            
            if (currentPiece !== null){
                
                currentPiece.handleMouseClick();
                
            }
            else {
                
                ((rows[i])[j]).handleMouseClick();
                
            }
        }
    }
    }
};

draw = function() {
     if (currentScene === 0) { splashScreen(); }
     else if (currentScene === 2) {endScreen();}
     else if (currentScene ===1) {
         
         boardInit();
    fill(255, 255, 255);
    
    for (var i = 0; i < rows.length; i++){
        for (var j = 0; j < (rows[i]).length; j++){
            if ((((rows[i])[j]).piece) !== null){
                (((rows[i])[j]).piece).draw();
            }
            
        }
    }
    
    if (isInCheck() && !checkingCheckmate){
        if(isCheckmate()){
            gameEnd = true;
        }
    }
    
    if (gameEnd){
        fill(0, 0, 0);
        rect(104, 171, 4*47.625, 58);
        fill(255, 255, 255);
        textSize(25);
        text("Checkmate!", 131, 208);
    }
         
     }
     else {currentScene = 2;}
};

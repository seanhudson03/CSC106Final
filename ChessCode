//Global
var currentScene = 0;  
var bitmojiX = 100;
var bitmojiY = 100;

//Function to create Sean's bitmoji on the screen
var drawSeanBitmoji = function (bitmojiObject){
    
    //Set bitmoji height to a fraction of the objects h value(Had to be modified for
    //correct sizing)
    var bitmojiHeight = (bitmojiObject.h)*(5/9);
    
    //Set bodyX and bodyY to object x with adjustment for displacement based on size
    var bodyX = bitmojiObject.x-bitmojiHeight;
    var bodyY = bitmojiObject.y-bitmojiHeight;
    
    //Set shirtColor to the object's shirtColor
    var shirtColor = bitmojiObject.shirtColor;
    
    //Set initialValue to the object's initials value(The variable could not be "initials" 
    //because the function to draw the initials shares that name
    var initialValue = bitmojiObject.initials;
    
    // Neck
    function neck(bodyX, bodyY, bitmojiHeight) {
        fill(255, 224, 189);
        rect(74 * (bitmojiHeight / 100) + bodyX, 139 * (bitmojiHeight / 100) + bodyY, 50 * (bitmojiHeight / 100), 30 * (bitmojiHeight / 100));
    }

    // Head
    function head(bodyX, bodyY, bitmojiHeight) {
        fill(255, 224, 189);
        ellipse(100 * (bitmojiHeight / 100) + bodyX, 100 * (bitmojiHeight / 100) + bodyY, 80 * (bitmojiHeight / 100), 100 * (bitmojiHeight / 100));
    }

    // Hair
    function hair(bodyX, bodyY, bitmojiHeight) {
        noStroke();
        fill(245, 212, 103);
        ellipse(100 * (bitmojiHeight / 100) + bodyX, 61 * (bitmojiHeight / 100) + bodyY, 70 * (bitmojiHeight / 100), 34 * (bitmojiHeight / 100));
        quad(
            64 * (bitmojiHeight / 100) + bodyX,
            56 * (bitmojiHeight / 100) + bodyY,
            80 * (bitmojiHeight / 100) + bodyX,
            46 * (bitmojiHeight / 100) + bodyY,
            92 * (bitmojiHeight / 100) + bodyX,
            77 * (bitmojiHeight / 100) + bodyY,
            59 * (bitmojiHeight / 100) + bodyX,
            92 * (bitmojiHeight / 100) + bodyY
        );
        quad(
            134 * (bitmojiHeight / 100) + bodyX,
            56 * (bitmojiHeight / 100) + bodyY,
            89 * (bitmojiHeight / 100) + bodyX,
            63 * (bitmojiHeight / 100) + bodyY,
            106 * (bitmojiHeight / 100) + bodyX,
            85 * (bitmojiHeight / 100) + bodyY,
            143 * (bitmojiHeight / 100) + bodyX,
            90 * (bitmojiHeight / 100) + bodyY
        );
    }

    // Eyes
    function eyes(bodyX, bodyY, bitmojiHeight) {
        stroke(0, 0, 0);
        fill(255, 255, 255);
        ellipse(82 * (bitmojiHeight / 100) + bodyX, 100 * (bitmojiHeight / 100) + bodyY, 18 * (bitmojiHeight / 100), 13 * (bitmojiHeight / 100));
        ellipse(118 * (bitmojiHeight / 100) + bodyX, 100 * (bitmojiHeight / 100) + bodyY, 18 * (bitmojiHeight / 100), 13 * (bitmojiHeight / 100));
        noStroke();
        fill(64, 139, 166);
        ellipse(82 * (bitmojiHeight / 100) + bodyX, 100 * (bitmojiHeight / 100) + bodyY, 9 * (bitmojiHeight / 100), 9 * (bitmojiHeight / 100));
        ellipse(118 * (bitmojiHeight / 100) + bodyX, 100 * (bitmojiHeight / 100) + bodyY, 9 * (bitmojiHeight / 100), 9 * (bitmojiHeight / 100));
        fill(0, 0, 0);
        ellipse(82 * (bitmojiHeight / 100) + bodyX, 100 * (bitmojiHeight / 100) + bodyY, 4 * (bitmojiHeight / 100), 4 * (bitmojiHeight / 100));
        ellipse(118 * (bitmojiHeight / 100) + bodyX, 100 * (bitmojiHeight / 100) + bodyY, 4 * (bitmojiHeight / 100), 4 * (bitmojiHeight / 100));
    }

    // Nose
    function nose(bodyX, bodyY, bitmojiHeight) {
        stroke(0, 0, 0);
        fill(255, 224, 189);
        bezier(
            98 * (bitmojiHeight / 100) + bodyX,
            119 * (bitmojiHeight / 100) + bodyY,
            110 * (bitmojiHeight / 100) + bodyX,
            123 * (bitmojiHeight / 100) + bodyY,
            109 * (bitmojiHeight / 100) + bodyX,
            103 * (bitmojiHeight / 100) + bodyY,
            98 * (bitmojiHeight / 100) + bodyX,
            97 * (bitmojiHeight / 100) + bodyY
        );
    }

    // Mouth
    function mouth(bodyX, bodyY, bitmojiHeight) {
        fill(237, 168, 168);
        ellipse(101 * (bitmojiHeight / 100) + bodyX, 131 * (bitmojiHeight / 100) + bodyY, 21 * (bitmojiHeight / 100), 8 * (bitmojiHeight / 100));
        line(
            91 * (bitmojiHeight / 100) + bodyX,
            131 * (bitmojiHeight / 100) + bodyY,
            109 * (bitmojiHeight / 100) + bodyX,
            131 * (bitmojiHeight / 100) + bodyY
        );
    }

    // EyeBlack
    function eyeBlack(bodyX, bodyY, bitmojiHeight) {
        fill(36, 36, 36);
        rect(
            73 * (bitmojiHeight / 100) + bodyX,
            108 * (bitmojiHeight / 100) + bodyY,
            18 * (bitmojiHeight / 100),
            5 * (bitmojiHeight / 100),
            30
        );
        rect(
            110 * (bitmojiHeight / 100) + bodyX,
            108 * (bitmojiHeight / 100) + bodyY,
            18 * (bitmojiHeight / 100),
            5 * (bitmojiHeight / 100),
            30
        );
    }

    // Shirt
    function shirt(bodyX, bodyY, bitmojiHeight) {
        //Use the object's shirtColor
        fill(shirtColor);
        arc(
            100 * (bitmojiHeight / 100) + bodyX,
            193 * (bitmojiHeight / 100) + bodyY,
            116 * (bitmojiHeight / 100),
            69 * (bitmojiHeight / 100),
            -180,
            0
        );
        noStroke();
        rect(41 * (bitmojiHeight / 100) + bodyX, 192 * (bitmojiHeight / 100) + bodyY, 118 * (bitmojiHeight / 100), 37 * (bitmojiHeight / 100));
        fill(255, 224, 189);
        triangle(
            74 * (bitmojiHeight / 100) + bodyX,
            156 * (bitmojiHeight / 100) + bodyY,
            124 * (bitmojiHeight / 100) + bodyX,
            156 * (bitmojiHeight / 100) + bodyY,
            101 * (bitmojiHeight / 100) + bodyX,
            178 * (bitmojiHeight / 100) + bodyY
        );
        stroke(0, 0, 0);
        line(41 * (bitmojiHeight / 100) + bodyX, 192 * (bitmojiHeight / 100) + bodyY, 41 * (bitmojiHeight / 100) + bodyX, 227 * (bitmojiHeight / 100) + bodyY);
        line(
            158 * (bitmojiHeight / 100) + bodyX,
            192 * (bitmojiHeight / 100) + bodyY,
            158 * (bitmojiHeight / 100) + bodyX,
            227 * (bitmojiHeight / 100) + bodyY
        );
    }

    // ShirtCollar
    function shirtCollar(bodyX, bodyY, bitmojiHeight) {
        //Use the object's shirt color again
        fill(shirtColor);
        quad(
            65 * (bitmojiHeight / 100) + bodyX,
            160 * (bitmojiHeight / 100) + bodyY,
            77 * (bitmojiHeight / 100) + bodyX,
            159 * (bitmojiHeight / 100) + bodyY,
            105 * (bitmojiHeight / 100) + bodyX,
            186 * (bitmojiHeight / 100) + bodyY,
            71 * (bitmojiHeight / 100) + bodyX,
            177 * (bitmojiHeight / 100) + bodyY
        );
        quad(
            133 * (bitmojiHeight / 100) + bodyX,
            160 * (bitmojiHeight / 100) + bodyY,
            121 * (bitmojiHeight / 100) + bodyX,
            159 * (bitmojiHeight / 100) + bodyY,
            98 * (bitmojiHeight / 100) + bodyX,
            185 * (bitmojiHeight / 100) + bodyY,
            129 * (bitmojiHeight / 100) + bodyX,
            175 * (bitmojiHeight / 100) + bodyY
        );
        rect(95 * (bitmojiHeight / 100) + bodyX, 184 * (bitmojiHeight / 100) + bodyY, 10 * (bitmojiHeight / 100), 18 * (bitmojiHeight / 100));
        triangle(
            112 * (bitmojiHeight / 100) + bodyX,
            171 * (bitmojiHeight / 100) + bodyY,
            101 * (bitmojiHeight / 100) + bodyX,
            183 * (bitmojiHeight / 100) + bodyY,
            117 * (bitmojiHeight / 100) + bodyX,
            183 * (bitmojiHeight / 100) + bodyY
        );
        triangle(
            88 * (bitmojiHeight / 100) + bodyX,
            171 * (bitmojiHeight / 100) + bodyY,
            84 * (bitmojiHeight / 100) + bodyX,
            183 * (bitmojiHeight / 100) + bodyY,
            102 * (bitmojiHeight / 100) + bodyX,
            183 * (bitmojiHeight / 100) + bodyY
        );
        fill(176, 212, 207);
        ellipse(100.5 * (bitmojiHeight / 100) + bodyX, 191 * (bitmojiHeight / 100) + bodyY, 4 * (bitmojiHeight / 100), 4 * (bitmojiHeight / 100));
        ellipse(100.5 * (bitmojiHeight / 100) + bodyX, 197 * (bitmojiHeight / 100) + bodyY, 4 * (bitmojiHeight / 100), 4 * (bitmojiHeight / 100));
    }

    // Initials
    function initials(bodyX, bodyY, bitmojiHeight) {
        fill(255, 255, 255);
        textSize(20 * (bitmojiHeight / 100));
        text("SH", 55 * (bitmojiHeight / 100) + bodyX, 188 * (bitmojiHeight / 100) + bodyY, 300, 300);
    }

    // Emblem
    function emblem(bodyX, bodyY, bitmojiHeight) {
        line(
            125 * (bitmojiHeight / 100) + bodyX,
            188 * (bitmojiHeight / 100) + bodyY,
            132 * (bitmojiHeight / 100) + bodyX,
            207 * (bitmojiHeight / 100) + bodyY
        );
        fill(224, 38, 38);
        triangle(
            125 * (bitmojiHeight / 100) + bodyX,
            188 * (bitmojiHeight / 100) + bodyY,
            130 * (bitmojiHeight / 100) + bodyX,
            200 * (bitmojiHeight / 100) + bodyY,
            145 * (bitmojiHeight / 100) + bodyX,
            190 * (bitmojiHeight / 100) + bodyY
        );
        noFill();
        stroke(255, 255, 255);
        ellipse(
            131 * (bitmojiHeight / 100) + bodyX,
            193 * (bitmojiHeight / 100) + bodyY,
            3 * (bitmojiHeight / 100),
            3 * (bitmojiHeight / 100)
        );
        line(
            133 * (bitmojiHeight / 100) + bodyX,
            193 * (bitmojiHeight / 100) + bodyY,
            139 * (bitmojiHeight / 100) + bodyX,
            190.5 * (bitmojiHeight / 100) + bodyY
        );
        fill(0, 0, 0);
        textSize(5 * (bitmojiHeight / 100));
        text("Keyport", 139 * (bitmojiHeight / 100) + bodyX, 199 * (bitmojiHeight / 100) + bodyY);
        text("Yacht", 132 * (bitmojiHeight / 100) + bodyX, 204 * (bitmojiHeight / 100) + bodyY);
        text("Club", 147 * (bitmojiHeight / 100) + bodyX, 204 * (bitmojiHeight / 100) + bodyY);
        textSize(6.5 * (bitmojiHeight / 100));
        text("Junior", 115 * (bitmojiHeight / 100) + bodyX, 212 * (bitmojiHeight / 100) + bodyY);
        text("Sailing", 135 * (bitmojiHeight / 100) + bodyX, 212 * (bitmojiHeight / 100) + bodyY);
        text("Instructor", 121 * (bitmojiHeight / 100) + bodyX, 219 * (bitmojiHeight / 100) + bodyY);
    }

    // Sunglasses
    function sunglasses(bodyX, bodyY, bitmojiHeight) {
        stroke(0, 0, 0);
        fill(37, 51, 16, 127);
        ellipse(104 * (bitmojiHeight / 100) + bodyX, 189 * (bitmojiHeight / 100) + bodyY, 15 * (bitmojiHeight / 100), 17 * (bitmojiHeight / 100));
        ellipse(104 * (bitmojiHeight / 100) + bodyX, 210 * (bitmojiHeight / 100) + bodyY, 15 * (bitmojiHeight / 100), 17 * (bitmojiHeight / 100));
        fill(0, 0, 0);
        line(
            111 * (bitmojiHeight / 100) + bodyX,
            211 * (bitmojiHeight / 100) + bodyY,
            111 * (bitmojiHeight / 100) + bodyX,
            188 * (bitmojiHeight / 100) + bodyY
        );
        line(
            108 * (bitmojiHeight / 100) + bodyX,
            202 * (bitmojiHeight / 100) + bodyY,
            108 * (bitmojiHeight / 100) + bodyX,
            195 * (bitmojiHeight / 100) + bodyY
        );
    }

    neck(bodyX, bodyY, bitmojiHeight);
    head(bodyX, bodyY, bitmojiHeight);
    hair(bodyX, bodyY, bitmojiHeight);
    eyes(bodyX, bodyY, bitmojiHeight);
    nose(bodyX, bodyY, bitmojiHeight);
    mouth(bodyX, bodyY, bitmojiHeight);
    eyeBlack(bodyX, bodyY, bitmojiHeight);
    shirt(bodyX, bodyY, bitmojiHeight);
    shirtCollar(bodyX, bodyY, bitmojiHeight);
    
    //Check if initials are true or false before drawing them
    if(initialValue === true){
        initials(bodyX, bodyY, bitmojiHeight);
    }
    emblem(bodyX, bodyY, bitmojiHeight);
    sunglasses(bodyX, bodyY, bitmojiHeight);
};


var drawHead = function (x, y, bitmojiHeight)

{
  var ratio = bitmojiHeight/100; 
    noStroke();
    fill(255, 224, 184); //skin color
    ellipse(x,y,83*ratio,100*ratio); //head
    fill(169, 125, 50); //hair color
    quad(x-43*ratio,y-7*ratio,x-29*ratio,y-36*ratio,x-12*ratio,y-48*ratio,x-34*ratio,y     +3*ratio); //left hair
    quad(x+43*ratio,y+1*ratio,x+34*ratio,y-32*ratio,x+13*ratio,y-50*ratio,x+35*ratio,y     -3*ratio); //right hair
    fill(0, 0, 0); //hat color
    ellipse(x+1*ratio,y-38*ratio,58*ratio,27*ratio); //hat
    fill(99,57,15); //eye color
    stroke(0, 0, 0);
    ellipse(x-12*ratio,y,6*ratio,4*ratio); //left eye
    ellipse(x+16*ratio,y,6*ratio,4*ratio); //right eye
    fill(255, 224, 184); //nose color
    bezier(x,y,x+21*ratio,y+22*ratio,x-8*ratio,y+20*ratio,x-4*ratio,y+15*ratio); //nose
    fill(255, 255, 255); //white for smile
    arc(x,y+25*ratio,29*ratio,13*ratio,1,180); //smile
    line(x-16*ratio,y+24*ratio,x+14*ratio,y+24*ratio); //line for smile
};

var drawShirt = function(x, y, bitmojiHeight){
var ratio = bitmojiHeight/100;   
    
    fill(0, 0, 0); //shirt color
    rect(x-35*ratio,y+50*ratio,71*ratio,63*ratio); //shirt
    rect(x-45*ratio,y+50*ratio,11*ratio,37*ratio); //left sholder sleeve
    rect(x+35*ratio,y+50*ratio,11*ratio,37*ratio); //right sholder sleeve
    fill(247, 247, 247); //text color
    textSize(20*ratio);
    text("CH",x-13*ratio,y+78*ratio);
};

//Function to draw Cam's bitmoji
var drawCamBitmoji = function(x, y, h){

    drawHead (x, y, h);
    drawShirt (x, y, h);
    };

//Button Constructor
var Button = function(config) {
    this.x = config.x || 0;
    this.y = config.y || 0;
    this.width = config.width || 150;
    this.height = config.height || 50;
    this.label = config.label || "Click";
    this.onClick = config.onClick || function() {};
};

//Button draw function
Button.prototype.draw = function() {
    fill(234, 221, 202);
    rect(this.x, this.y, this.width, this.height, 5);
    fill(0, 0, 0);
    textSize(19);
    //textAlign(LEFT, TOP);
    text(this.label, this.x+44, this.y+this.height-20);
};

//Button is mouse inside check
Button.prototype.isMouseInside = function() {
    return mouseX > this.x &&
           mouseX < (this.x + this.width) &&
           mouseY > this.y &&
           mouseY < (this.y + this.height);
};

//Button mouse click handler
Button.prototype.handleMouseClick = function() {
    if (this.isMouseInside()) {
        this.onClick();
    }
};

//Use previous button constructor to create START button
var startButton = new Button({
    x: 121,
    y: 300,
    label: "START",
    onClick: function() {
        currentScene = 1;
        
    }
});

//Draw the splashscreen
var splashScreen = function ()
{
    background(110, 28, 13);
    drawCamBitmoji(347,39,55);
    drawSeanBitmoji({
    x:48,
    y:39,
    h:89,
    shirtColor:color(255, 255, 255),
    initials:false});
    fill(234, 221, 202);
    textSize(25);
    text ("By Cameron and Sean ", 71,184);
    textSize(40);
    text("Chess", 143,122);
    textSize(20);
    text("Click the start button to start the game",28,238);
    startButton.draw();
    startButton.draw();
};

//Draw the end game screen
var endScreen = function ()
{
    background(255, 0, 0);
    
};

//Global turn variable, determines who is able to move
var turn = "white";

//Simulation flag, see simulateMove
var simulation = false;

//Flag for game end
var gameEnd = false;

//Flag to prevent recursion
var checkingCheckmate = false;

//Tile constructor
var Tile = function(tileX, tileY, tileRight, tileUp){
    
    this.tileX = tileX;
    this.tileY = tileY;
    this.tileLeftBound = tileX;
    this.tileRightBound = tileX+47.625;
    this.tileTopBound = tileY;
    this.tileBottomBound = tileY+ 47.625;
    this.tileRight = tileRight;
    this.tileUp = tileUp;
    this.piece = null;
    
};

//Piece constructor
var Piece = function(type, tileRight, tileUp, team){
    
    this.type = type;
    this.team = team;
    this.tileRight = tileRight;
    this.tileUp = tileUp;
    this.selected = false;
    
};

//Create array for rows
var rows = [];

//Draw piece
Piece.prototype.draw = function(){
    
    //Determine color
    if (this.team === "white"){
        
        stroke(255, 255, 255);
        strokeWeight(1);
        fill(255, 255, 255);
    }
    else {
        stroke(0, 0, 0);
        strokeWeight(1);
        fill(0, 0, 0);
    }
    
    textSize(12);
    
    //Simplify variables
    var tileRight = this.tileRight;
    var tileUp = this.tileUp;
    
    // Check if tile indices are valid
    if (tileRight !== null && tileUp !== null && rows[tileRight] && (rows[tileRight])[tileUp]) {
        
        //Simplify tile variable
        var tile = this.getTile();
        
        //Color in ellipse red to signify selection
        if (this.selected) {
        fill(255, 0, 0, 35); // Red with 100 alpha (semi-transparent)
        rect(tile.tileX, tile.tileY, 47.625, 47.625);
    }
        
        ellipse(tile.tileX+24, tile.tileY+24, 40, 40);
        
        //Determine text color
        if (this.team === "white"){
            stroke(0, 0, 0);
            strokeWeight(1);
            fill(0, 0, 0);
            
        }
        else {
            stroke(255, 255, 255);
            strokeWeight(1);
            fill(255, 255, 255);
        }
        
        //Adjustment for text placement based on length to allow centering
        var textAdjust;
        if (this.type === "rook"){
            
            textAdjust = 12;
            
        }
        else if(this.type === "queen"){
            
            textAdjust = 7;
            
        }
        else if(this.type === "bishop"){
            
            textAdjust = 6;
            
        }
        else if(this.type === "knight"){
            
            textAdjust = 8;
            
        }
        else if(this.type === "pawn"){
            
            textAdjust = 9;
            
        }
        
        //Write name of piece unless the piece is a king
        if (this.type !== "king"){
        
            text(this.type, tile.tileX+textAdjust, tile.tileY+27);
        
        }
        else if (this.type === "king"){
            
            //Draw Cam's bitmoji in ellipse for the black king
            if (this.team === "black"){
                
                drawCamBitmoji(tile.tileX+24,tile.tileY+16,22);
                
            }
            
            //Draw Sean's bitmoji in ellipse for the white king
            else if(this.team === "white"){
                
                drawSeanBitmoji({
                x:tile.tileX+23,
                y:tile.tileY+15,
                h:34,
                shirtColor:color(67, 183, 204),
                initials:false});
                
            }
            
        }
        
    }
};

//Function to make tile values easily accessible, I guess this is abstraction
Piece.prototype.getTile = function(){
    
    var tile = (rows[this.tileRight])[this.tileUp];
    return tile;
    
};

//Function to locate king of whoever's turn it is currently
var findKing = function(){
    
    var kingPiece = null;
    
    for (var i = 0; i < rows.length; i++) {
        for (var j = 0; j < rows[i].length; j++) {
            
            var checkTile = rows[i][j];
            
            if (checkTile.piece !== null) {
                
                var checkPiece = checkTile.piece;
                
                if (checkPiece.team === turn && checkPiece.type === "king"){
                    
                    //Return the tile object that the king is on
                    return checkTile;
                    
                }
            }
        }
    }
};

//Function to determine validity of pawn's move, returns true if the move is legal
var pawnCheck = function(currentPiece, targetTile){
    
    var type = currentPiece.type;
    var team = currentPiece.team;
    
    //Variable to allow for pawns to only move in their respective direction
    var backwards = 1;
    
    var turn = currentPiece.team;
    
    //Determine whose turn it is
    if (team === "black"){
        backwards = -1;
        }
        
        //Get the current tile value of the piece
        var tile = currentPiece.getTile();
        
        //Check if the move follows pawn formula
        if(targetTile.tileUp === tile.tileUp+(1*backwards)){
            
            //Make sure tile is empty
            if (targetTile.piece === null && targetTile.tileRight=== tile.tileRight){
                return true;
            }
            //If the tile is not empty, make sure it is an enemy piece one diagonal away
            else if (targetTile.piece !== null){
                if ((targetTile.piece.team !== turn) && (targetTile.tileRight === tile.tileRight + 1 || targetTile.tileRight === tile.tileRight - 1)){
                    return true;
                }
            }
            
        }
        
        //Allow pawns to move 2 spaces on first turn
        else if((targetTile.tileUp === tile.tileUp+(2*backwards))&&currentPiece.firstTurn === true && targetTile.tileRight === tile.tileRight){
            
            return true;
        }
    
};

//Function to determine validity of bishop's move
var bishopCheck = function(currentPiece, targetTile){
    
    var type = currentPiece.type;
    var team = currentPiece.team;
    var turn = currentPiece.team;
    
    var currentTile = currentPiece.getTile();
        
        //Determine dx and dy of the move
        var dx = (targetTile.tileRight - currentTile.tileRight);
        var dy = (targetTile.tileUp - currentTile.tileUp);
        
        //If their absolute values are equivalent, they are moving in a legal diagonal
        if (abs(dx) === abs(dy)){
            
            //Check which diagonal they are following
            if (dx > 0 && dy > 0){
                //Up and Right
                
                //Farthest the bishop can move is 8 diagonal spaces
                for (var i = 1; i < 8; i++){
                    
                    //Check each tile in the given diagonal
                    var checkTile = (((rows[currentTile.tileRight+i])[currentTile.tileUp+i]));
                    //If tile is not empty
                    if (checkTile.piece !== null){
                        
                        //Determine if the tile holds an enemy piece
                        if ((checkTile.piece).team !== turn){
                            
                            //If the tile holds an enemy piece and is the desired tile,
                            //allow the move
                            if (checkTile === targetTile){
                                
                                return true;
                                
                            }
                            //If not, the move is blocked, break the loop
                            else{
                                break;
                            }
                            
                        }
                        //Break the loop
                        else{
                            break;
                        }
                    
                    }
                    //If the tile is empty, and the loop didn't break, the move should be valid
                    else{
                        
                        //Make sure that the desired tile and the tile being checked are the same
                        if (checkTile === targetTile){
                            
                            return true;
                            
                        }
                        
                    }
                }
            }
            
            //Same process as above, but different direction
            else if (dx > 0 && dy < 0){
                //Down and Right
                
                for (var i = 1; i < 8; i++){
                    
                    var checkTile = (((rows[currentTile.tileRight+i])[currentTile.tileUp-i]));
                    
                    if (checkTile.piece !== null){
                        
                        if ((checkTile.piece).team !== turn){
                                
                            if (checkTile === targetTile){
                                
                                return true;
                                
                            }
                            else{
                                break;
                            }
                            
                        }
                        else{
                            break;
                        }
                    
                    }
                    else{
                        
                        if (checkTile === targetTile){
                            
                            return true;
                            
                        }
                        
                    }
                }
                
            }
            //Same process as above, but different direction
            else if (dx < 0 && dy > 0){
                //Up and Left
                
                for (var i = 1; i < 8; i++){
                    
                    var checkTile = (((rows[currentTile.tileRight-i])[currentTile.tileUp+i]));
                    
                    if (checkTile.piece !== null){
                        
                        if ((checkTile.piece).team !== turn){
                                
                            if (checkTile === targetTile){
                                
                                return true;
                                
                            }
                            else{
                                break;
                            }
                            
                        }
                        else{
                            break;
                        }
                    
                    }
                    else{
                        
                        if (checkTile === targetTile){
                            
                            return true;
                            
                        }
                        
                    }
                }
            }
            //Same process as above, but different direction
            else if (dx < 0 && dy < 0){
                //Down and Left
                
                for (var i = 1; i < 8; i++){
                    
                    var checkTile = (((rows[currentTile.tileRight-i])[currentTile.tileUp-i]));
                    
                    if (checkTile.piece !== null){
                        
                        if ((checkTile.piece).team !== turn){
                                
                            if (checkTile === targetTile){
                                
                                return true;
                                
                            }
                            else{
                                break;
                            }
                            
                        }
                        else{
                            break;
                        }
                    
                    }
                    else{
                        
                        if (checkTile === targetTile){
                            
                            return true;
                            
                        }
                        
                    }
                }
            }
            
            
        }
    
};

//Same concept as bishop, except left, right, up, or down instead of diagonal
var rookCheck = function(currentPiece, targetTile){
    
    var type = currentPiece.type;
    var team = currentPiece.team;
    var turn = currentPiece.team;
    
    var currentTile = currentPiece.getTile();
        
        var dx = (targetTile.tileRight - currentTile.tileRight);
        var dy = (targetTile.tileUp - currentTile.tileUp);
            
            
            if (dx === 0 || dy === 0){
                
                if (dy !== 0){
                for (var i = 1; i < 8; i++){
                    
                    var multiplier = 1;
                    if (dy < 0){
                        multiplier = -1;
                    }
                    var checkTile = (((rows[currentTile.tileRight])[currentTile.tileUp+(i*multiplier)]));
                    
                    if (checkTile.piece !== null){
                        
                        if ((checkTile.piece).team !== turn){
                                
                            if (checkTile === targetTile){
                                
                                return true;
                                
                            }
                            else{
                                break;
                            }
                            
                        }
                        else{
                            break;
                        }
                    
                    }
                    else{
                        
                        if (checkTile === targetTile){
                            
                            return true;
                            
                        }
                        
                    }
                }
                
                }
                
                if (dx !== 0){
                for (var i = 1; i < 8; i++){
                    
                    var multiplier = 1;
                    if (dx < 0){
                        multiplier = -1;
                    }
                    var checkTile = (((rows[currentTile.tileRight+(i*multiplier)])[currentTile.tileUp]));
                    
                    if (checkTile.piece !== null){
                        
                        if ((checkTile.piece).team !== turn){
                                
                            if (checkTile === targetTile){
                                
                                return true;
                                
                            }
                            else{
                                break;
                            }
                            
                        }
                        else{
                            break;
                        }
                    
                    }
                    else{
                        
                        if (checkTile === targetTile){
                            
                            return true;
                            
                        }
                        
                    }
                }
                }
            }
    
};

//Knight legality check
var knightCheck = function(currentPiece, targetTile){
    
    var type = currentPiece.type;
    var team = currentPiece.team;
    var turn = currentPiece.team;
    
    var currentTile = currentPiece.getTile();
        
        //Make sure the target tile is vertical 2 and horizontal 1, or vice versa
        var dx = abs(targetTile.tileRight - currentTile.tileRight);
        var dy = abs(targetTile.tileUp - currentTile.tileUp);
        
        if ((dx === 2 && dy === 1) || (dx === 1 && dy === 2)){
            
            if (targetTile.piece !== null){
                
                if ((targetTile.piece).team !== turn){
                    return true;
                }
                
            }
            else {
                return true;
            }
            
        }
    
};

//Check king's move
var kingCheck = function(currentPiece, targetTile){
    
    var type = currentPiece.type;
    var team = currentPiece.team;
    var turn = currentPiece.team;
    
    //Make sure that the king is attempting to move to any tile in the 8 tile surrounding area
    
    var currentTile = currentPiece.getTile();
        
    var dx = abs(targetTile.tileRight - currentTile.tileRight);
    var dy = abs(targetTile.tileUp - currentTile.tileUp);
    
    if ((dx <= 1 && dy <= 1) && !(dx === 0 && dy === 0)){
        if (targetTile.piece !== null){
            if ((targetTile.piece).team !== turn){
                
                return true;
                
            }
        }
        else{
            return true;
        }
    }
    
};

//Function to handle moves and legality of all piece
var checkValidMove = function(currentPiece, targetTile){
    
    //Check type of piece
    var type = currentPiece.type;
    
    //Based on type, call respective check functions and simulate the move to see if the move results in checking their own king or not removing the king from check
    //If both checks pass, the move function is called
    if (type === "pawn"){
        
        if (pawnCheck(currentPiece, targetTile) && currentPiece.simulateMove(currentPiece, targetTile)){
            
            currentPiece.move(targetTile.tileRight, targetTile.tileUp);
            
        }
        
    }
    
    else if(type === "bishop"){
        
        if (bishopCheck(currentPiece, targetTile)&& currentPiece.simulateMove(currentPiece, targetTile)){
            currentPiece.move(targetTile.tileRight, targetTile.tileUp);
        }
        
    }
    
    else if(type === "rook"){
        
        if (rookCheck(currentPiece, targetTile)&& currentPiece.simulateMove(currentPiece, targetTile)){
            currentPiece.move(targetTile.tileRight, targetTile.tileUp);
        }
        
    }
    
    else if (type === "queen"){
        
        if ((rookCheck(currentPiece, targetTile) || bishopCheck(currentPiece, targetTile))&& currentPiece.simulateMove(currentPiece, targetTile)){
            currentPiece.move(targetTile.tileRight, targetTile.tileUp);
        }
        
    }
    
    else if(type === "knight"){
        
        if (knightCheck(currentPiece, targetTile)&& currentPiece.simulateMove(currentPiece, targetTile)){
            
            currentPiece.move(targetTile.tileRight, targetTile.tileUp);
            
        }
        
    }
    
    else if(type === "king"){
        
        //Don't forget to add in a check for check
        if (kingCheck(currentPiece, targetTile)&& currentPiece.simulateMove(currentPiece, targetTile)&& currentPiece.simulateMove(currentPiece, targetTile)){
            
            currentPiece.move(targetTile.tileRight, targetTile.tileUp);
            
        }
        
    }
    
};

//Function to determine if the king is in check
var isInCheck = function(){
    
    //Locate current king
    var kingTile = findKing();
    var inCheck = false;
    
    //Iterate through all tiles
    for (var i = 0; i < rows.length; i++) {
        for (var j = 0; j < rows[i].length; j++) {
            
            //Check current tile
            var checkTile = (rows[i])[j];
            
            //If tile is not empty
            if (checkTile.piece !== null) {
                
                //Get the piece of that tile
                var checkPiece = checkTile.piece;
                
                //If the piece's team is not the current team
                if (checkPiece.team !== turn){
                    
                    //Run through every possible piece, and determine if capturing the king is a legal move. If it is, then the king is in check. Set inCheck to true.
                    if (checkPiece.type === "pawn"){
                        
                        if (pawnCheck(checkPiece, kingTile)){
                            
                            
                            inCheck = true;
                        }
                    }
                    else if (checkPiece.type === "rook"){
                        
                        if (rookCheck(checkPiece, kingTile)){
                            
                            inCheck = true;
                        }
                    }
                    else if (checkPiece.type === "knight"){
                        
                        if (knightCheck(checkPiece, kingTile)){
                            
                            inCheck = true;
                        }
                    }
                    else if (checkPiece.type === "bishop"){
                        
                        if (bishopCheck(checkPiece, kingTile)){
                            
                            inCheck = true;
                        }
                    }
                    else if (checkPiece.type === "queen"){
                        
                        if (rookCheck(checkPiece, kingTile) || bishopCheck(checkPiece, kingTile)){
                            
                            inCheck = true;
                        }
                    }
                    else if (checkPiece.type === "king"){
                        if (kingCheck(checkPiece, kingTile)){
                            
                            inCheck = true;
                        }
                    }
                }
            }
        }
    }
    
    //Return the inCheck boolean
    return inCheck;
    
};

//Function to check for checkmate
var isCheckmate = function(){
    
    //Set the flag
    checkingCheckmate = true;
    
    var currentTurn = turn;
    var movesPossible = false;
    
    textAlign(BASELINE);
    
    //Iterate through all tiles
    for (var i = 0; i < rows.length; i++) {
        
        for (var j = 0; j < rows[i].length; j++) {
            
            //Set piece to empty
            var piece = null;
            
            //If the current tile being checked is not empty, set piece to that tile's piece
            if ((rows[i])[j].piece !== null){
                piece = (rows[i])[j].piece;
            }
            
            //Consider only pieces of the current player's team
            if (piece !== null && piece.team === currentTurn) {
                
                // Check all possible moves for the current piece
                for (var x = 0; x < rows.length; x++) {
                    for (var y = 0; y < rows[x].length; y++) {
                        
                        var targetTile = (rows[x])[y];
                        
                        // If the move is valid and doesn't result in check, it's not checkmate               
                        if (piece.type === "pawn"){
                            if (pawnCheck(piece, targetTile) && piece.simulateMove(piece, targetTile)) {
                             movesPossible = true;// Not checkmate
                            
                        }
                        }
                        else if(piece.type === "rook"){
                            if (rookCheck(piece, targetTile) && piece.simulateMove(piece, targetTile)) {
                             movesPossible = true;// Not checkmate
                            
                        }
                        }
                        else if(piece.type === "knight"){
                            if (knightCheck(piece, targetTile) && piece.simulateMove(piece, targetTile)) {
                             movesPossible = true;// Not checkmate
                            
                        }
                        }
                        else if(piece.type === "bishop"){
                            if (bishopCheck(piece, targetTile) && piece.simulateMove(piece, targetTile)) {
                             movesPossible = true;// Not checkmate
                            
                        }
                        }
                        else if(piece.type === "queen"){
                            if ((bishopCheck(piece, targetTile)||rookCheck(piece, targetTile)) && piece.simulateMove(piece, targetTile)) {
                             movesPossible = true;// Not checkmate
                            
                        }
                        }
                        else if(piece.type === "king"){
                            
                            if (kingCheck(piece, targetTile) && piece.simulateMove(piece, targetTile)) {
                            
                             movesPossible = true;// Not checkmate
                            
                        }
                        }
                        
                    }
                }
            }
        }
    }
    
    //If no valid move can get the king out of check, it's checkmate
    return !movesPossible;
    
};

//Function to move pieces
Piece.prototype.move = function(newInd, newInd2){
    
    //New tile of piece being moved
    var newTile = ((rows[newInd])[newInd2]);
    
    //Old tile of piece being moved
    var oldTile = this.getTile();
    
    //Remember the piece that's moving
    var tempPiece = oldTile.piece;
    
    //Remove the selection
    tempPiece.selected = false;
    
    //Set new indices of the piece
    tempPiece.tileRight = newInd;
    tempPiece.tileUp = newInd2;
    
    //Remove piece from original tile
    oldTile.piece = null;
    
    //Set the target tiles piece to the moving piece, either filling in the empty piece property or replacing the enemy team's piece in the situation of a capture
    newTile.piece = tempPiece;
    
    //Set new indices
    newTile.tileRight = newInd;
    newTile.tileUp = newInd2;
    
    //Change the turn
    if (turn === "white"){
        turn = "black";
    }
    else{
        turn = "white";
    }
    
    //Make sure the piece's first turn property is no longer true
    if (this.firstTurn === true){
        this.firstTurn = false;
    }
    
    //Check if this move is a simulation, refer to simulateMove for more detail
    if (simulation === false){
        checkingCheckmate = false;
    }
   
};

//Simulate a move to determine if it results in check
Piece.prototype.simulateMove = function(piece, targetTile) {
    
    // Store the original state
    simulation = true;
    var originalTurn = turn;
    var originalTile = piece.getTile();
    var originalPieceAtTarget = null;
    
    //If the target has a piece, set the originalPieceAtTarget value to that piece
    if (targetTile.piece !== null){
        originalPieceAtTarget = targetTile.piece;
    }
    
    // Apply the move
    piece.move(targetTile.tileRight, targetTile.tileUp);

    // Check the result
    turn = originalTurn;
    
    //Determine if the move resulted in checkmate
    var isInCheckAfterMove = isInCheck();
    
    // Revert changes
    piece.move(originalTile.tileRight, originalTile.tileUp);
    
    if (originalPieceAtTarget !== null){
        
        targetTile.piece = originalPieceAtTarget;
    
    }
    
    //End the function
    turn = originalTurn;
    simulation = false;
    return !isInCheckAfterMove;
    
};

//Function to draw the board itself every frame
var boardInit = function(){
    
    background(110, 38, 14);
    noFill();
    strokeWeight(2);
    stroke(234, 221, 202);
    rect(8, 8, 384, 384);
    
    strokeWeight(1);
    
    stroke(0, 0, 0);
    
    line(9, 9, 390, 9);
    for (var i = 0; i < 8; i++){
        
        for (var j = 0; j < 8; j++){
            
            if ((j%2)=== 0  && i%2 === 0){
                fill(234,221,202);
            }
            else if (i%2 !== 0 && j%2 !==0){
                fill(234, 221, 202);
            } 
            else {
                fill(110, 28, 13);
            }
            rect((47.625*j)+9,(47.625*i)+9, 47.625, 47.625);
            
        }
    }
    
};

//I think this array was from an unused idea, but I am too nervous to delete it :(
var letters = ["a", "b", "c", "d", "e", "f", "g", "h"];

//Fill rows array with arrays for columns, creating a 2d array to store tiles
for (var i = 0; i < 8; i++){
    
    var row = [];
    
    for (var j = 0; j < 8; j++){
        
        row.push(new Tile((47.625*i)+9, (47.625*j)+9, i, 7-j));
        
    }
    
    //Reverse the column to make the column more usable in other code
    row = row.reverse();
    rows.push(row);

}

//Create Pawns
for (var i = 0; i < 16; i++){
    
    if (i < 8){
        
        ((rows[i])[1]).piece = (new Piece("pawn", i, 1, "white"));
        (((rows[i])[1]).piece).firstTurn = true;
    }
    else{
        ((rows[i-8])[6]).piece = (new Piece("pawn", i-8, 6, "black"));
        (((rows[i-8])[6]).piece).firstTurn = true;
    }
    
}

//Create other pieces
//Bishops

((rows[2])[0]).piece = (new Piece("bishop", 2,0, "white"));
((rows[5])[0]).piece = (new Piece("bishop", 5,0, "white"));
((rows[2])[7]).piece = (new Piece("bishop", 2,7, "black"));
((rows[5])[7]).piece = (new Piece("bishop", 5,7, "black"));

//Rooks
((rows[0])[0]).piece = (new Piece("rook", 0,0, "white"));
((rows[7])[0]).piece = (new Piece("rook", 7,0, "white"));
((rows[0])[7]).piece = (new Piece("rook", 0,7, "black"));
((rows[7])[7]).piece = (new Piece("rook", 7,7, "black"));

//Queens
((rows[3])[0]).piece = (new Piece("queen", 3,0, "white"));
((rows[3])[7]).piece = (new Piece("queen", 3,7, "black"));

//Knights
((rows[1])[0]).piece = (new Piece("knight", 1,0, "white"));
((rows[6])[0]).piece = (new Piece("knight", 6,0, "white"));
((rows[1])[7]).piece = (new Piece("knight", 1,7, "black"));
((rows[6])[7]).piece = (new Piece("knight", 6,7, "black"));

//Kings
((rows[4])[0]).piece = (new Piece("king", 4,0, "white"));
((rows[4])[7]).piece = (new Piece("king", 4,7, "black"));

//Function to get the currently selected piece
var getSelectedPiece = function() {
    for (var i = 0; i < rows.length; i++) {
        for (var j = 0; j < rows[i].length; j++) {
            var currentPiece = rows[i][j].piece;
            if (currentPiece && currentPiece.selected) {
                return currentPiece;
            }
        }
    }
    return null;
};

//Function to handle clicked piece
Piece.prototype.onClick = function(){
    
    var tile = this.getTile();
    
    if (turn === this.team){
    for (var i = 0; i < rows.length; i++) {
        for (var j = 0; j < rows[i].length; j++) {
            if (rows[i][j].piece !== null) {
                rows[i][j].piece.selected = false;
            }
        }
    }

    // Select the current piece
    this.selected = !this.selected;
    }
    
    //Make sure checkValidMove is called if an enemy piece is clicked while another piece is selected
    else if(turn !== this.team){
        var selectedPiece = getSelectedPiece();
        
        if (selectedPiece) {
            checkValidMove(selectedPiece, tile);
        }
    }
};

//Handler for tiles being clicked
Tile.prototype.onClick = function(){
    
    //Check if a piece is selected already to then handle a possible move
    for (var i = 0; i < rows.length; i++){
        for (var j = 0; j < (rows[i]).length; j++){
            var currentPiece = (((rows[i])[j]).piece);
            
            if (currentPiece !== null){
                
                if (currentPiece.selected === true){
                    checkValidMove(currentPiece, this);
                }
            }
        }
    }
    
};

//Check for mouse being inside of a pieces boundaries(The tile it's on)
Piece.prototype.isMouseInside = function() {
    
    var tile = this.getTile();
    
    return mouseX > tile.tileLeftBound &&
           mouseX < (tile.tileRightBound) &&
           mouseY > tile.tileTopBound &&
           mouseY < (tile.tileBottomBound);
};

//Same check but for tiles
Tile.prototype.isMouseInside = function() {
    return mouseX > this.tileLeftBound &&
           mouseX < (this.tileRightBound) &&
           mouseY > this.tileTopBound &&
           mouseY < (this.tileBottomBound);
    
};

//Handler for piece clicks
Piece.prototype.handleMouseClick = function() {
    if (this.isMouseInside()) {
        
        this.onClick();
    }
};

//Handler for tile clicks
Tile.prototype.handleMouseClick = function() {

    if (this.isMouseInside()) {
        this.onClick();
    }
    
};

//Function for when the mouse is clicked
mouseClicked = function() {
    
    //Handle start button
    if (currentScene === 0){
        
        startButton.handleMouseClick();
        
    }
    //Handle game clicks
    else if(currentScene === 1){
    for (var i = 0; i < rows.length; i++){
        for (var j = 0; j < (rows[i]).length; j++){
            var currentPiece = (((rows[i])[j]).piece);
            
            if (currentPiece !== null){
                
                currentPiece.handleMouseClick();
                
            }
            else {
                
                ((rows[i])[j]).handleMouseClick();
                
            }
        }
    }
    }
};

//Draw function
draw = function() {
    //Draw based on current scene
     if (currentScene === 0) { splashScreen(); }
     else if (currentScene === 2) {endScreen();}
     else if (currentScene ===1) {
         
         //Draw board
         boardInit();
    fill(255, 255, 255);
    
    //Draw pieces
    for (var i = 0; i < rows.length; i++){
        for (var j = 0; j < (rows[i]).length; j++){
            if ((((rows[i])[j]).piece) !== null){
                (((rows[i])[j]).piece).draw();
            }
            
        }
    }
    
    //Check for checkmate
    if (isInCheck() && !checkingCheckmate){
        if(isCheckmate()){
            //If checkmated, end the game
            gameEnd = true;
        }
    }
    
    //If game is over, draw the end screen
    if (gameEnd){
        fill(0, 0, 0);
        rect(104, 171, 4*47.625, 58);
        fill(255, 255, 255);
        textSize(25);
        text("Checkmate!", 131, 208);
    }
         
     }
     else {currentScene = 2;}
};
